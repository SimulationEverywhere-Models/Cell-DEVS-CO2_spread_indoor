#!/usr/bin/env python
# coding: utf-8

# # ScenariosGenerator Class
# 
# **Purpose:** The generator class includes all the functions that are needed to generate JSON scenarios; each representing a room with one vent. The generated scenarios has all possible locations of vents given an inptut scenarios.
# 
# **Project:** CO2 dispersion
# 
# This is used for Cell-DEVS Cadmium models

# Things to do to clean the code
# -find the commonalities between generator:generate_scenario  and generator::generate_along_dim to reuse the code instead of duplicating it
# -find commonalities between create_seats and create_vent_scenario

# In[1]:


import sys
import os
import json
import copy
import subprocess

class ScenariosGenerator:
    # Function: __init__
    # Purpose: set variables to generate the scenarios
    # Arguments:
    #     self: enclosing instance (automatic, not user specified)
    #     config: configuration as a Python dictionary
    # Return:
    #     none
    
    def __init__ (self, in_file):
        config_dic = self.read_config(in_file)
        self.in_scenario_file = config_dic["in_scenario_file"]
        self.scenarios_path = config_dic["scenarios_path"]
        self.vent_size = config_dic["vent_size"]
        self.max = config_dic["max_number_of_scenarios"]
        self.vent_type = config_dic["vent_type"]
        self.occupant_type = config_dic["occupant_type"]

        
        #converting the initial input scenarop file to a dictionary
        self.scenario = self.read_scenario(self.in_scenario_file)


    # Function: loadScenario
    # Purpose: read the scenario file
    # Arguments:
        #   scenarioFile: A JSON file that has the model scenario
    # Return:
        #   scenario: converted JSON scenario into a dictionary 

    def read_scenario (self, scenario_file):
        scenario = ""
        try:
            with open(scenario_file, "r") as f:
                scenario = f.read()
        except FileNotFoundError:
            print("ERROR: Could not load scenario file")
            sys.exit(1)

        scenario = json.loads(scenario)  # Convert JSON string into dictionary

        return scenario    

    # Function: get_vents_info
    # Purpose: get information related to the vents (for 2D scenarios, just the concentration)
    # Arguments: none
    # Return: the concentration of the vents as set in the input scenario
    
    def get_vents_info(self):
        conc = self.scenario["scenario"]["default_config"]["CO2_cell"]["vent_conc"]
        return conc
    
    # Function: get_seats)info
    # Purpose: get information related to the seating areas of occupants. For now, base air concentration in the room before an occupant start 
    #breathing
    # Arguments: none
    # Return: the concentration of the background air before occipants arrive as set in the input scenario
        
    def get_seats_info(self):
        conc = self.scenario["scenario"]["default_config"]["CO2_cell"]["base"]
        return conc

    # Function: generateVentsScenarios
    # Purpose: generate 2D scenario files (JSON) with all possible locations given a model
    # Arguments: none
    # Return: none

    def generate_vents_scenarios (self):
        #get the model dimensions
        dimensions = self.scenario["scenario"]["shape"]
        number_of_scenarios = 0

        number_of_scenarios = self.generate_along_dim([0,0], 0, dimensions[0], number_of_scenarios)
        number_of_scenarios = self.generate_along_dim([0,0], 1, dimensions[1], number_of_scenarios)
        number_of_scenarios = self.generate_along_dim([0,dimensions[1]-1], 0, dimensions[0], number_of_scenarios)
        number_of_scenarios = self.generate_along_dim([dimensions[0]-1,0], 1, dimensions[1], number_of_scenarios)

    # Function: generate_along_dim
    # Purpose: generates scenario files (JSON) each is identical to the input scenario, but with an inserted vent of a given size. 
         #The generated scenarios represent all possible locations of a vent along a given dimension
    # Arguments: 
        #start_coords: the beginnign coords to insert the vent in
        #dimension: the dimension along which the vents will be inserted (one vent per scenario)
        #lengt: the maximum length along the inptu dimension after which no vent should be inserted
        #number_of_scenarios: number of scenarios generated before calling this function
    # Return:
        #total number of scenarios generated by the end fo the funciton

    def generate_along_dim (self, start_coords, dimension, length, number_of_scenarios):
        coords = start_coords

        conc = self.get_vents_info()
        
        #generate scenarios as long as the total number is less than the number of scenarios and we have not reached the max length
        while coords[dimension] <= length and self.max > number_of_scenarios:
            vent_cells = []

            #generate vent cells to be stored in JSON
            for j in range(self.vent_size):
                cell = self.make_cell(coords, vent_type, conc)
                vent_cells.append(copy.deepcopy(cell))
                coords[dimension] = coords[dimension]+1

            #insert the new vent_cells in the original scenario
            #this deep copy may not be efficient
            new_scenario = copy.deepcopy(self.scenario)

            new_scenario["cells"] = vent_cells + new_scenario["cells"]
            
            #save the scenario dictionary to disk
            self.ensure_dir(self.scenarios_path)
            with open(self.scenarios_path + "scenario_" + str(number_of_scenarios)+".json", "w") as f:
                f.write(json.dumps(new_scenario, indent=4))

            number_of_scenarios = number_of_scenarios + 1

        return number_of_scenarios
    
    # Function: create_vent_scenario
    # Purpose: Create a scenario-given an input file scenario, create a scenario with the new vent location
    # Arguments: vent_loc_arr: a numpy array containing locations of vents. The pair of values vent_loc_arr[0] and vent_loc_arr[1] for instance are
                #the x y coordinates of the top left corner of the first vent.
    # Return: name of the newly generated JSON scenario
    
    def create_vent_scenario(self, vent_loc_arr):
        #because the genetic algorithm sends the parameter as ndarray
        #the json serialziation is expecting a list
        vents_loc = vent_loc_arr.tolist()
        
        conc = self.get_vents_info()
        vent_cells = []

        #generate vent cells to be stored in JSON
        for j in range(0, len(vents_loc), 2):
            vent_loc=[]
            vent_loc.append(vents_loc[j])
            vent_loc.append(vents_loc[j+1])  
            for i in range(self.vent_size):
                cell = self.make_cell(vent_loc, self.vent_type, conc)
                vent_cells.append(copy.deepcopy(cell))
                vent_loc[0] = vent_loc[0]+1
            
            vent_loc[1] = vent_loc[1]+1
            for i in range(self.vent_size):
                vent_loc[0] = vent_loc[0]-1
                cell = self.make_cell(vent_loc, self.vent_type, conc)
                vent_cells.append(copy.deepcopy(cell))
                    
        #insert the new vent_cells in the original scenario
        #this deep copy may not be efficient
        new_scenario = copy.deepcopy(self.scenario)
        new_scenario["cells"] = vent_cells + new_scenario["cells"]

        scenario_name = "scenario_" + str(vent_loc)+"_GA.json"
        #save the scenario dictionary to disk
        
        self.ensure_dir(self.scenarios_path)
        with open(self.scenarios_path + scenario_name, "w") as f:
            f.write(json.dumps(new_scenario, indent=4))
        
        return scenario_name
   
    # Function: create_vent_scenario
    # Purpose:  Create a scenario-given an input file scenario, create a scenario with the new seatings location
    # Arguments: seats_loc_arr: a numpy array containing locations of seats. The pair of values seats_loc_arr[0] and seats_loc_arr[1] for instance are
                        #the x y coordinates of the first occupant.
                #index: this is appended to the name of the generated scenarios if the caller wants to keep all the scenarios
    # Return: name of the newly generated JSON scenario
   
    def create_seats_scenario(self, seats_loc_arr, index):

        seats_loc = seats_loc_arr.tolist()
        conc = self.get_seats_info()
        seats_cells = []

        #generate seats cells to be stored in JSON
        for j in range(0, len(seats_loc), 2):
            seat_loc=[]
            seat_loc.append(seats_loc[j])
            seat_loc.append(seats_loc[j+1])            
            cell = self.make_cell(seat_loc, self.occupant_type, conc)
            seats_cells.append(copy.deepcopy(cell))

        #insert the new vent_cells in the original scenario
        #this deep copy may not be efficient
        new_scenario = copy.deepcopy(self.scenario)
        new_scenario["cells"] = seats_cells + new_scenario["cells"]

        scenario_name = "scenario_seats" + str(index)+".json"
        #save the scenario dictionary to disk
        self.ensure_dir(self.scenarios_path)
        with open(self.scenarios_path + scenario_name, "w") as f:
            f.write(json.dumps(new_scenario, indent=4))

        return scenario_name
    
    # Function: make_cell
    # Purpose:  make a cell to be inserted in the JSON file
    # Arguments: coords: list of integers (e.g., [10,8])
                #type_code: the type of the cell to be inserted (e.g., -600 for a vent cell)
                #conc: an int representing the intial concentraiton of the created cell
    # Return: the cell structure
    
    def make_cell(self, coords, type_code, conc):
        return {
                "cell_id": coords,
                "state" : {
                    "concentration" : conc,
                    "type" : type_code,
                    "counter" : 0
                    }
                }

    # Function: read_config
    # Purpose: read the configuration needed to generate the scenarios
    # Arguments:
        #config_file: A JSON file that has the
            #in_scenario: initial json scenario file
            #scnearios_path: location where the generated scenarios will be stored
            #vent_size: vent's size in cells
            #max_number_of_scenarios: the maximum number of scenarios to be generated
            #model_path: the path where the cadmium model can be found to run the simulations
    # Return:
        #scenario: converted JSON scenario into a dictionary   

    def read_config(self, config_file):
        try:
            with open(config_file, "r") as f:
                config = f.read()
        except FileNotFoundError:
            print("ERROR: Could not load scenario file")
            sys.exit(1)

        config_dic = json.loads(config)
        return config_dic
        
    def ensure_dir(self, file_path):
        directory = os.path.dirname(file_path)
        if not os.path.exists(directory):
            os.makedirs(directory)